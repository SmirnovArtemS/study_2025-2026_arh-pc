---
## Author
author:
  name: Смирнов Артём Сергеевич, НПИбд-02-25
  degrees: DSc
  orcid: 0000-0002-0877-7063
  email: 1032252364@pfur.ru
  affiliation:
    - name: Российский университет дружбы народов
      country: Российская Федерация
      postal-code: 117198
      city: Москва
      address: ул. Миклухо-Маклая, д. 6

## Title
title: "Отчет по лабораторной работе №9"
subtitle: "Лабораторная работа №9. Понятие подпрограммы. Отладчик GDB."
license: "CC BY"
---

# Цель работы

Приобретение навыков написания программ с использованием подпрограмм. Знакомство с методами отладки при помощи GDB и его основными возможностями.

# Задание

1. Преобразуйте программу из лабораторной работы №8 (Задание №1 для самостоятельной работы), реализовав вычисление значения функции f(x) как подпрограмму.
2. В листинге 9.3 приведена программа вычисления выражения (3 + 2) ∗ 4 + 5. При запуске данная программа дает неверный результат. Проверьте это. С помощью отладчика GDB, анализируя изменения значений регистров, определите ошибку и исправьте ее.

![](image/listing9_3-1.png){#fig-001 width=90%}
![](image/listing9_3-2.png){#fig-001 width=90%}

# Выполнение лабораторной работы

## Порядок выполнения лабораторной работы

### Реализация подпрограмм в NASM

![Создание директории ~/work/arch-pc/lab09 и последующее создание в нём файла lab9-1.asm](image/1.png){#fig-001 width=90%}

![Запись кода программы с использованием вызова подпрограммы](image/2.png){#fig-001 width=90%}

![Создание исполняемого файла и запуск программы](image/3.png){#fig-002 width=90%}

Программа работает корректно([@fig-002])

![Изменение программы с добавление новой подпрограммы _subcalcul](image/4.png){#fig-001 width=90%}

![Создание исполняемого файла и запуск программы](image/5.png){#fig-001 width=90%}

### Отладка программам с помощью GDB

![Создание файла lab09-1.asm](image/6.png){#fig-001 width=90%}

![Запись кода программы вывода сообщения Hello world!](image/7.png){#fig-001 width=90%}

![Создание исполняемого файла с ключом -g и запуск программы с отладкой GDB](image/8.png){#fig-001 width=90%}

![Установка брейкпоинт на метку _start и ее запуск](image/9.png){#fig-001 width=90%}

![Просмотр дисассимилированного кода программы используя команду disassemble, начиная с метки _start](image/10.png){#fig-001 width=90%}

![Переключение на отображение команд с Intel'овским синтаксисом](image/11.png){#fig-001 width=90%}

Различия отображения синтаксиса машинных команд в режимах ATT и Intel:

1. Указание адресов - В ATT синтаксисе адреса указываются в круглых скобках, в Intel же адреса указываются без каких-либо скобок.

2. Разделители операндов - В ATT - разделители операндов ",", а в Intel'овском синтаксисе разделители могут быть как ",", так и "/". 

3. Порядок расположения операндов - В Intel порядок прямой, результирующий операнд указывается первым, а исходный указывается вторым. В ATT синтаксисе порядок обратный, сначала указывается исходный операнд, а после результирующий операнд. 

4. Знаки операндов -  В ATT синтаксисе операнды с позитивными значениями предваряются символом “". в Intel же "”.

5. Префиксы/суффиксы в размере операндов - В ATT синтаксисе размер операнда указывается перед операндом с использованием префиксов, таких как “b”, “w” , “l”  и “q”. В Intel'овском же синтаксисе размер операнда указывается только после операнда с использованием суффиксов - это как “b”, “w”, “d”, “q”.

6.Обозначение регистров: В ATT синтаксисе обозначение регистра начинается с такого символа как “%”. В Intel синтаксисе обозначение регистра может начинаться с символа как “R” или “E”.

![Включение режима псевдографики для более удобного анализа программы](image/12.png){#fig-001 width=90%}

#### Добавление точек останова 

![Проверка наличие точки останова по имени метки _start](image/13.png){#fig-001 width=90%}

![Установка ещё одной точки останова по адресу предпоследней инструкции](image/14.png){#fig-001 width=90%}

![Проверка установки точки останова](image/15.png){#fig-001 width=90%}

#### Работа с данными программы GDB

![Выполнение 5 инструкций и отслеживание изменений регистров](image/16.png){#fig-001 width=90%}

При выполнение команд менялись регистры ecx, ebx, eax, eip, edx

![Просмотр значение переменной msg1 по имени](image/17.png){#fig-001 width=90%}

![Просмотр значение переменной msg2 по адрессу](image/18.png){#fig-001 width=90%}

![Изменение первого символа в msg1](image/19.png){#fig-001 width=90%}

![Изменение первого символа в msg2](image/20.png){#fig-001 width=90%}

![Просмотр регистра edx в шестнадцатеричном, двоичном формате и в символьном виде)](image/21.png){#fig-001 width=90%}

![Изменяем значение регистра ebx](image/22.png){#fig-003 width=90%}

Выводятся разные значения, потому что кавычки приписывают регистру вводимое значение([@fig-003])

![Завершение работы программы и выход из GDB(случайно дважды прописал команды)](image/23.png){#fig-001 width=90%}

#### Обработка аргументов командной строки в GDB

![Копирование lab8-2.asm в lab09-3.asm](image/24.png){#fig-001 width=90%}

![Создание исполняемого файла и запуск программы с запиью аргументов](image/25.png){#fig-001 width=90%}

![Установка точки останова](image/26.png){#fig-001 width=90%}

![Изучение полученных данных](image/27.png){#fig-004 width=90%}

Наш шаг изменения равен 4 так как адресные регистры имеют размерность 32 бита или 4 байта([@fig-004])

## Задание для самостоятельной работы

1. Преобразуйте программу из лабораторной работы №8 (Задание №1 для самостоятельной работы), реализовав вычисление значения функции f(x) как подпрограмму.

![Копирование файла lab8-4.asm в lab09-4.asm](image/28.png){#fig-001 width=90%}

![Изменение кода с добавление подпрограммы](image/29.png){#fig-001 width=90%}

![Создание исполняемого файла, запуск и проверка корректности выполнения](image/30.png){#fig-001 width=90%}

2. В листинге 9.3 приведена программа вычисления выражения (3 + 2) ∗ 4 + 5. При запуске данная программа дает неверный результат. Проверьте это. С помощью отладчика GDB, анализируя изменения значений регистров, определите ошибку и исправьте ее.

![Создание файла lab09-5.asm](image/31.png){#fig-001 width=90%}

![Записывание в файл код программы вычисления выражения (3 + 2) ∗ 4 + 5](image/32.png){#fig-001 width=90%}

![Создание исполняемого файла и его запуск с проверкой](image/33.png){#fig-005 width=90%}

Действительно программа работает не корректно ([@fig-005])

![Поиск и обнаружение ошибки](image/34.png){#fig-001 width=90%}

![Изменение кода программы, для его корректной работы](image/35.png){#fig-001 width=90%}

![Создание исполняемого файла с исправленным кодом и его запуск](image/36.png){#fig-006 width=90%}

Всё работает корректно ([@fig-006])

# Выводы

Приобрел навыки написания программ с использованием подпрограмм. Познакомился с методами отладки при помощи GDB и его основными возможностями.

# Список литературы{.unnumbered}

1. GDB: The GNU Project Debugger. — URL: https://www.gnu.org/software/gdb/.
2. GNU Bash Manual. — 2016. — URL: https://www.gnu.org/software/bash/manual/.
3. Midnight Commander Development Center. — 2021. — URL: https://midnight-commander.org/.
4. NASM Assembly Language Tutorials. — 2021. — URL: https://asmtutor.com/.
5. Newham C. Learning the bash Shell: Unix Shell Programming. — O’Reilly Media, 2005. —354 с. — (In a Nutshell). — ISBN 0596009658. — URL: http://www.amazon.com/Learningbash-Shell-Programming-Nutshell/dp/0596009658.
6. Robbins A. Bash Pocket Reference. — O’Reilly Media, 2016. — 156 с. — ISBN 978-1491941591.
7. The NASM documentation. — 2021. — URL: https://www.nasm.us/docs.php.
8. Zarrelli G. Mastering Bash. — Packt Publishing, 2017. — 502 с. — ISBN 9781784396879.
9. Колдаев В. Д., Лупин С. А. Архитектура ЭВМ. — М. : Форум, 2018.
10. Куляс О. Л., Никитин К. А. Курс программирования на ASSEMBLER. — М. : Солон-Пресс,2017.
11. Новожилов О. П. Архитектура ЭВМ и систем. — М. : Юрайт, 2016.
12. Расширенный ассемблер: NASM. — 2021. — URL: https://www.opennet.ru/docs/RUS/nasm/.
13. Робачевский А., Немнюгин С., Стесик О. Операционная система UNIX. — 2-е изд. — БХВПетербург, 2010. — 656 с. — ISBN 978-5-94157-538-1.
14. Столяров А. Программирование на языке ассемблера NASM для ОС Unix. — 2-е изд. — М. : МАКС Пресс, 2011. — URL: http://www.stolyarov.info/books/asm_unix.
15. Таненбаум Э. Архитектура компьютера. — 6-е изд. — СПб. : Питер, 2013. — 874 с. — (Классика Computer Science).
16. Таненбаум Э., Бос Х. Современные операционные системы. — 4-е изд. — СПб. : Питер, 2015. — 1120 с. — (Классика Computer Science).

::: {#refs}
:::
